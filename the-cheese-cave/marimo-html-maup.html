<!DOCTYPE html> <html><head>
		<title>Marimo HTML MAUP</title>
		<base href="../">
		<meta id="root-path" root-path="../">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes, minimum-scale=1.0, maximum-scale=5.0">
		<meta charset="UTF-8">
		<meta name="description" content="Cheese ðŸ§€ Bytes - Marimo HTML MAUP">
		<meta property="og:title" content="Marimo HTML MAUP">
		<meta property="og:description" content="Cheese ðŸ§€ Bytes - Marimo HTML MAUP">
		<meta property="og:type" content="website">
		<meta property="og:url" content="https://cheesebytes.com/the-cheese-cave/marimo-html-maup.html">
		<meta property="og:image" content="undefined">
		<meta property="og:site_name" content="Cheese ðŸ§€ Bytes">
		<meta name="author" content="guiferviz"><link rel="alternate" type="application/rss+xml" title="RSS Feed" href="https://cheesebytes.com/lib/rss.xml"><script async="" id="webpage-script" src="lib/scripts/webpage.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script type="module" async="" id="graph-view-script" src="lib/scripts/graph-view.js"></script><script async="" id="graph-wasm-script" src="lib/scripts/graph-wasm.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="graph-render-worker-script" src="lib/scripts/graph-render-worker.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="tinycolor-script" src="lib/scripts/tinycolor.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="pixi-script" src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.4.0/pixi.min.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="minisearch-script" src="https://cdn.jsdelivr.net/npm/minisearch@6.3.0/dist/umd/index.min.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><link rel="icon" href="lib/media/favicon.png"><script async="" id="graph-data-script" src="lib/scripts/graph-data.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><style>body{--line-width:40em;--line-width-adaptive:40em;--file-line-width:40em;--sidebar-width:min(20em, 80vw);--collapse-arrow-size:11px;--tree-horizontal-spacing:0.6em;--tree-vertical-spacing:0.6em;--sidebar-margin:12px}.sidebar{height:100%;min-width:calc(var(--sidebar-width) + var(--divider-width-hover));max-width:calc(var(--sidebar-width) + var(--divider-width-hover));font-size:14px;z-index:10;position:relative;overflow:hidden;transition:min-width ease-in-out,max-width ease-in-out;transition-duration:.2s;contain:size}.sidebar-left{left:0}.sidebar-right{right:0}.sidebar.is-collapsed{min-width:0;max-width:0}body.floating-sidebars .sidebar{position:absolute}.sidebar-content{height:100%;min-width:calc(var(--sidebar-width) - var(--divider-width-hover));top:0;padding:var(--sidebar-margin);padding-top:4em;line-height:var(--line-height-tight);background-color:var(--background-secondary);transition:background-color,border-right,border-left,box-shadow;transition-duration:var(--color-fade-speed);transition-timing-function:ease-in-out;position:absolute;display:flex;flex-direction:column}.sidebar:not(.is-collapsed) .sidebar-content{min-width:calc(max(100%,var(--sidebar-width)) - 3px);max-width:calc(max(100%,var(--sidebar-width)) - 3px)}.sidebar-left .sidebar-content{left:0;border-top-right-radius:var(--radius-l);border-bottom-right-radius:var(--radius-l)}.sidebar-right .sidebar-content{right:0;border-top-left-radius:var(--radius-l);border-bottom-left-radius:var(--radius-l)}.sidebar:has(.sidebar-content:empty):has(.topbar-content:empty){display:none}.sidebar-topbar{height:2em;width:var(--sidebar-width);top:var(--sidebar-margin);padding-inline:var(--sidebar-margin);z-index:1;position:fixed;display:flex;align-items:center;transition:width ease-in-out;transition-duration:inherit}.sidebar.is-collapsed .sidebar-topbar{width:calc(2.3em + var(--sidebar-margin) * 2)}.sidebar .sidebar-topbar.is-collapsed{width:0}.sidebar-left .sidebar-topbar{left:0}.sidebar-right .sidebar-topbar{right:0}.topbar-content{overflow:hidden;overflow:clip;width:100%;height:100%;display:flex;align-items:center;transition:inherit}.sidebar.is-collapsed .topbar-content{width:0;transition:inherit}.clickable-icon.sidebar-collapse-icon{background-color:transparent;color:var(--icon-color-focused);padding:0!important;margin:0!important;height:100%!important;width:2.3em!important;margin-inline:0.14em!important;position:absolute}.sidebar-left .clickable-icon.sidebar-collapse-icon{transform:rotateY(180deg);right:var(--sidebar-margin)}.sidebar-right .clickable-icon.sidebar-collapse-icon{transform:rotateY(180deg);left:var(--sidebar-margin)}.clickable-icon.sidebar-collapse-icon svg.svg-icon{width:100%;height:100%}.sidebar-section-header{margin:0 0 1em 0;text-transform:uppercase;letter-spacing:.06em;font-weight:600}body{transition:background-color var(--color-fade-speed) ease-in-out}.webpage-container{display:flex;flex-direction:row;height:100%;width:100%;align-items:stretch;justify-content:center}.document-container{opacity:1;flex-basis:100%;max-width:100%;width:100%;height:100%;display:flex;flex-direction:column;align-items:center;transition:opacity .2s ease-in-out;contain:inline-size}.hide{opacity:0;transition:opacity .2s ease-in-out}.document-container>.markdown-preview-view{margin:var(--sidebar-margin);margin-bottom:0;width:100%;width:-webkit-fill-available;width:-moz-available;width:fill-available;background-color:var(--background-primary);transition:background-color var(--color-fade-speed) ease-in-out;border-top-right-radius:var(--window-radius,var(--radius-m));border-top-left-radius:var(--window-radius,var(--radius-m));overflow-x:hidden!important;overflow-y:auto!important;display:flex!important;flex-direction:column!important;align-items:center!important;contain:inline-size}.document-container>.markdown-preview-view>.markdown-preview-sizer{padding-bottom:80vh!important;width:100%!important;max-width:var(--line-width)!important;flex-basis:var(--line-width)!important;transition:background-color var(--color-fade-speed) ease-in-out;contain:inline-size}.markdown-rendered img:not([width]),.view-content img:not([width]){max-width:100%;outline:0}.document-container>.view-content.embed{display:flex;padding:1em;height:100%;width:100%;align-items:center;justify-content:center}.document-container>.view-content.embed>*{max-width:100%;max-height:100%;object-fit:contain}:has(> :is(.math,table)){overflow-x:auto!important}.document-container>.view-content{overflow-x:auto;contain:content;padding:0;margin:0;height:100%}.scroll-highlight{position:absolute;width:100%;height:100%;pointer-events:none;z-index:1000;background-color:hsla(var(--color-accent-hsl),.25);opacity:0;padding:1em;inset:50%;translate:-50% -50%;border-radius:var(--radius-s)}</style><script defer="">async function loadIncludes(){if("file:"!=location.protocol){let e=document.querySelectorAll("include");for(let t=0;t<e.length;t++){let o=e[t],l=o.getAttribute("src");try{const e=await fetch(l);if(!e.ok){console.log("Could not include file: "+l),o?.remove();continue}let t=await e.text(),n=document.createRange().createContextualFragment(t),i=Array.from(n.children);for(let e of i)e.classList.add("hide"),e.style.transition="opacity 0.5s ease-in-out",setTimeout((()=>{e.classList.remove("hide")}),10);o.before(n),o.remove(),console.log("Included file: "+l)}catch(e){o?.remove(),console.log("Could not include file: "+l,e);continue}}}else{if(document.querySelectorAll("include").length>0){var e=document.createElement("div");e.id="error",e.textContent="Web server exports must be hosted on an http / web server to be viewed correctly.",e.style.position="fixed",e.style.top="50%",e.style.left="50%",e.style.transform="translate(-50%, -50%)",e.style.fontSize="1.5em",e.style.fontWeight="bold",e.style.textAlign="center",document.body.appendChild(e),document.querySelector(".document-container")?.classList.remove("hide")}}}document.addEventListener("DOMContentLoaded",(()=>{loadIncludes()}));let isFileProtocol="file:"==location.protocol;function waitLoadScripts(e,t){let o=e.map((e=>document.getElementById(e+"-script"))),l=0;!function e(){let n=o[l];l++,n&&"true"!=n.getAttribute("loaded")||l<o.length&&e(),l<o.length?n.addEventListener("load",e):t()}()}</script><link rel="stylesheet" href="lib/styles/obsidian.css"><link rel="preload" href="lib/styles/global-variable-styles.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/global-variable-styles.css"></noscript><link rel="preload" href="lib/styles/main-styles.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/main-styles.css"></noscript><link rel="preload" href="lib/styles/snippets.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/snippets.css"></noscript></head><body class="publish css-settings-manager theme-dark native-scrollbars show-inline-title show-ribbon"><script defer="">let theme=localStorage.getItem("theme")||(window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light");"dark"==theme?(document.body.classList.add("theme-dark"),document.body.classList.remove("theme-light")):(document.body.classList.add("theme-light"),document.body.classList.remove("theme-dark")),window.innerWidth<480?document.body.classList.add("is-phone"):window.innerWidth<768?document.body.classList.add("is-tablet"):window.innerWidth<1024?document.body.classList.add("is-small-screen"):document.body.classList.add("is-large-screen")</script><div class="webpage-container workspace"><div class="sidebar-left sidebar"><div class="sidebar-handle"></div><div class="sidebar-topbar"><div class="topbar-content"><label class="theme-toggle-container" for="theme_toggle"><input class="theme-toggle-input" type="checkbox" id="theme_toggle"><div class="toggle-background"></div></label></div><div class="clickable-icon sidebar-collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><path d="M21 3H3C1.89543 3 1 3.89543 1 5V19C1 20.1046 1.89543 21 3 21H21C22.1046 21 23 20.1046 23 19V5C23 3.89543 22.1046 3 21 3Z"></path><path d="M10 4V20"></path><path d="M4 7H7"></path><path d="M4 10H7"></path><path d="M4 13H7"></path></svg></div></div><div class="sidebar-content"><div class="search-input-container"><input enterkeyhint="search" type="search" spellcheck="false" placeholder="Search..."><div class="search-input-clear-button" aria-label="Clear search"></div></div><include src="lib/html/file-tree.html"></include></div><script defer="">let ls = document.querySelector(".sidebar-left"); ls.classList.add("is-collapsed"); if (window.innerWidth > 768) ls.classList.remove("is-collapsed"); ls.style.setProperty("--sidebar-width", localStorage.getItem("sidebar-left-width"));</script></div><div class="document-container markdown-reading-view hide"><div class="markdown-preview-view markdown-rendered allow-fold-headings allow-fold-lists is-readable-line-width"><style id="MJX-CHTML-styles"></style><div class="markdown-preview-sizer markdown-preview-section"><h1 class="page-title heading inline-title" id="Marimo HTML MAUP"><p dir="auto">Marimo HTML MAUP</p></h1><div class="el-p"><p dir="auto">Hola! Esto es parecido a <a data-href="Marimo HTML" href="Marimo HTML" class="internal-link" target="_self" rel="noopener nofollow">Marimo HTML</a>.</p></div><div class="el-pre"><pre class="language-marimorena" tabindex="0"><code data-line="0" class="language-marimorena is-loaded">import marimo as mo
import anywidget
import traitlets
import random


def generate_points(n, canvas_size, seed=None):
    if seed:
        random.seed(seed)
    return [{"x": random.uniform(0, canvas_size), "y": random.uniform(0, canvas_size)} for _ in range(n)]


class MAUPWidget(anywidget.AnyWidget):
    _esm = r"""
    function render({ model, el }) {
      let canvasSize = model.get("canvas_size") || 500;
      let gridType = model.get("grid_type") || "square";
      let cellSize = parseFloat(model.get("cell_size") || "50");
      let orientation = parseFloat(model.get("orientation") || "0");
      let points = model.get("points") || [];
      let heatmapColors = model.get("heatmap_colors");
      let offsetX = parseFloat(model.get("grid_origin_x") || "0");
      let offsetY = parseFloat(model.get("grid_origin_y") || "0");
      let applyFilter = model.get("apply_filter");  // new flag

      const canvas = document.createElement("canvas");
      canvas.width = canvasSize;
      canvas.height = canvasSize;
      canvas.style.border = "1px solid #ccc";
      el.innerHTML = "";
      el.appendChild(canvas);
      const ctx = canvas.getContext("2d");

      let dragging = false;
      let dragStartX = 0, dragStartY = 0;
      let startOffsetX = offsetX, startOffsetY = offsetY;

      const sqrt3 = Math.sqrt(3);

      function parseHexColor(hex) {
        let r = parseInt(hex.slice(1,3), 16);
        let g = parseInt(hex.slice(3,5), 16);
        let b = parseInt(hex.slice(5,7), 16);
        let a = 1.0;
        if(hex.length === 9) {
          a = parseInt(hex.slice(7,9), 16) / 255;
        }
        return {r, g, b, a};
      }

      function interpolateBetween(color1, color2, factor) {
        factor = Math.min(Math.max(factor, 0), 1);
        const c1 = parseHexColor(color1);
        const c2 = parseHexColor(color2);
        const r = Math.round(c1.r + factor * (c2.r - c1.r));
        const g = Math.round(c1.g + factor * (c2.g - c1.g));
        const b = Math.round(c1.b + factor * (c2.b - c1.b));
        const a = c1.a + factor * (c2.a - c1.a);
        return `rgba(${r}, ${g}, ${b}, ${a})`;
      }

      function getHeatmapColor(intensity) {
        let n = heatmapColors.length;
        if (n === 0) return "rgba(0,0,0,1)";
        if (n === 1) return heatmapColors[0];
        let segment = intensity * (n - 1);
        let index = Math.floor(segment);
        let factor = segment - index;
        if (index &gt;= n - 1) return heatmapColors[n - 1];
        return interpolateBetween(heatmapColors[index], heatmapColors[index + 1], factor);
      }

      function toGridCoords(x, y) {
        const rx = x - offsetX;
        const ry = y - offsetY;
        const theta = orientation * Math.PI / 180;
        const cosT = Math.cos(theta);
        const sinT = Math.sin(theta);
        return {
          x: rx * cosT + ry * sinT,
          y: -rx * sinT + ry * cosT
        };
      }

      function getSquareGridBounds() {
        const corners = [
          { x: 0, y: 0 },
          { x: canvas.width, y: 0 },
          { x: canvas.width, y: canvas.height },
          { x: 0, y: canvas.height }
        ];
        let xs = [], ys = [];
        for (const pt of corners) {
          const gridPt = toGridCoords(pt.x, pt.y);
          xs.push(gridPt.x);
          ys.push(gridPt.y);
        }
        const minX = Math.min(...xs);
        const maxX = Math.max(...xs);
        const minY = Math.min(...ys);
        const maxY = Math.max(...ys);
        const iMin = Math.floor(minX / cellSize);
        const iMax = Math.ceil(maxX / cellSize) - 1;
        const jMin = Math.floor(minY / cellSize);
        const jMax = Math.ceil(maxY / cellSize) - 1;
        return { iMin, iMax, jMin, jMax };
      }

      function getHexGridBounds() {
        const corners = [
          { x: 0, y: 0 },
          { x: canvas.width, y: 0 },
          { x: canvas.width, y: canvas.height },
          { x: 0, y: canvas.height }
        ];
        let qs = [], rs = [];
        const theta = orientation * Math.PI / 180;
        const cosT = Math.cos(theta);
        const sinT = Math.sin(theta);
        for (const pt of corners) {
          const rx = pt.x - offsetX;
          const ry = pt.y - offsetY;
          const gridX = rx * cosT + ry * sinT;
          const gridY = -rx * sinT + ry * cosT;
          const q = (gridX * (sqrt3/3) - gridY/3) / cellSize;
          const r = (gridY * (2/3)) / cellSize;
          qs.push(q);
          rs.push(r);
        }
        const minQ = Math.floor(Math.min(...qs));
        const maxQ = Math.ceil(Math.max(...qs));
        const minR = Math.floor(Math.min(...rs));
        const maxR = Math.ceil(Math.max(...rs));
        return { minQ, maxQ, minR, maxR };
      }

      // --- Gaussian filter functions ---
      function applyGaussianFilterSquare(counts, bounds) {
        let newCounts = new Map();
        let kernel = [
          [0.0625, 0.125, 0.0625],
          [0.125,  0.25,  0.125],
          [0.0625, 0.125, 0.0625]
        ];
        for (let i = bounds.iMin; i &lt;= bounds.iMax; i++) {
          for (let j = bounds.jMin; j &lt;= bounds.jMax; j++) {
            let sum = 0;
            for (let di = -1; di &lt;= 1; di++) {
              for (let dj = -1; dj &lt;= 1; dj++) {
                let key = `${i+di},${j+dj}`;
                let value = counts.get(key) || 0;
                sum += kernel[di+1][dj+1] * value;
              }
            }
            newCounts.set(`${i},${j}`, sum);
          }
        }
        return newCounts;
      }

      function applyGaussianFilterHex(counts, bounds) {
        let newCounts = new Map();
        // Define neighbor offsets for axial coordinates in hex grid:
        let neighbors = [[1,0], [-1,0], [0,1], [0,-1], [1,-1], [-1,1]];
        let centerWeight = 0.5;
        let neighborWeight = 0.0833333;  // 1/12 so that total weight sums to 1
        for (let q = bounds.minQ - 1; q &lt;= bounds.maxQ + 1; q++) {
          for (let r = bounds.minR - 1; r &lt;= bounds.maxR + 1; r++) {
            let sum = centerWeight * (counts.get(`${q},${r}`) || 0);
            for (let k = 0; k &lt; neighbors.length; k++) {
              let dq = neighbors[k][0], dr = neighbors[k][1];
              let key = `${q+dq},${r+dr}`;
              sum += neighborWeight * (counts.get(key) || 0);
            }
            newCounts.set(`${q},${r}`, sum);
          }
        }
        return newCounts;
      }
      // --- End Gaussian filter functions ---

      // CÃ¡lculo de recuento de puntos for square grid
      function computeSquareCounts() {
        const counts = new Map();
        const theta = orientation * Math.PI / 180;
        const cosT = Math.cos(theta);
        const sinT = Math.sin(theta);
        for (const p of points) {
          const rx = p.x - offsetX;
          const ry = p.y - offsetY;
          const gridX = rx * cosT + ry * sinT;
          const gridY = -rx * sinT + ry * cosT;
          const i = Math.floor(gridX / cellSize);
          const j = Math.floor(gridY / cellSize);
          const key = `${i},${j}`;
          counts.set(key, (counts.get(key) || 0) + 1);
        }
        return counts;
      }

      function computeHexCounts() {
        const counts = new Map();
        const theta = orientation * Math.PI / 180;
        const cosT = Math.cos(theta);
        const sinT = Math.sin(theta);
        for (const p of points) {
          const rx = p.x - offsetX;
          const ry = p.y - offsetY;
          const gridX = rx * cosT + ry * sinT;
          const gridY = -rx * sinT + ry * cosT;
          const q_frac = (gridX * (sqrt3/3) - gridY/3) / cellSize;
          const r_frac = (gridY * (2/3)) / cellSize;
          let q = q_frac, r = r_frac, s = -q - r;
          let rq = Math.round(q);
          let rr = Math.round(r);
          let rs = Math.round(s);
          const q_diff = Math.abs(rq - q);
          const r_diff = Math.abs(rr - r);
          const s_diff = Math.abs(rs - s);
          if (q_diff &gt; r_diff &amp;&amp; q_diff &gt; s_diff) {
            rq = -rr - rs;
          } else if (r_diff &gt; s_diff) {
            rr = -rq - rs;
          } else {
            rs = -rq - rr;
          }
          const key = `${rq},${rr}`;
          counts.set(key, (counts.get(key) || 0) + 1);
        }
        return counts;
      }

      function drawSquareGrid() {
        const bounds = getSquareGridBounds();
        let counts = computeSquareCounts();
        if (applyFilter) {
          counts = applyGaussianFilterSquare(counts, bounds);
        }
        let maxCount = 0;
        for (let i = bounds.iMin; i &lt;= bounds.iMax; i++) {
          for (let j = bounds.jMin; j &lt;= bounds.jMax; j++) {
            const key = `${i},${j}`;
            const count = counts.get(key) || 0;
            if (count &gt; maxCount) maxCount = count;
          }
        }
        const theta = orientation * Math.PI / 180;
        const cosT = Math.cos(theta);
        const sinT = Math.sin(theta);

        for (let i = bounds.iMin; i &lt;= bounds.iMax; i++) {
          for (let j = bounds.jMin; j &lt;= bounds.jMax; j++) {
            const key = `${i},${j}`;
            const count = counts.get(key) || 0;
            const intensity = maxCount ? (count / maxCount) : 0;
            const color = getHeatmapColor(intensity);
            ctx.fillStyle = color;
            const corners = [
              { x: i * cellSize,         y: j * cellSize },
              { x: (i+1) * cellSize,       y: j * cellSize },
              { x: (i+1) * cellSize,       y: (j+1) * cellSize },
              { x: i * cellSize,         y: (j+1) * cellSize }
            ];
            ctx.beginPath();
            for (let k = 0; k &lt; corners.length; k++) {
              const gx = corners[k].x;
              const gy = corners[k].y;
              const globalX = offsetX + gx * cosT - gy * sinT;
              const globalY = offsetY + gx * sinT + gy * cosT;
              if (k === 0) ctx.moveTo(globalX, globalY);
              else ctx.lineTo(globalX, globalY);
            }
            ctx.closePath();
            ctx.fill();
          }
        }
      }

      function drawHexGrid() {
        const bounds = getHexGridBounds();
        let counts = computeHexCounts();
        if (applyFilter) {
          counts = applyGaussianFilterHex(counts, bounds);
        }
        let maxCount = 0;
        for (let q = bounds.minQ - 1; q &lt;= bounds.maxQ + 1; q++) {
          for (let r = bounds.minR - 1; r &lt;= bounds.maxR + 1; r++) {
            const key = `${q},${r}`;
            const count = counts.get(key) || 0;
            if (count &gt; maxCount) maxCount = count;
          }
        }
        const theta = orientation * Math.PI / 180;
        const cosT = Math.cos(theta);
        const sinT = Math.sin(theta);
        const R = cellSize;  // use cellSize as radius
        const hexCorners = [
          { x: 0, y: -R },
          { x: (sqrt3/2) * R, y: -0.5 * R },
          { x: (sqrt3/2) * R, y: 0.5 * R },
          { x: 0, y: R },
          { x: - (sqrt3/2) * R, y: 0.5 * R },
          { x: - (sqrt3/2) * R, y: -0.5 * R }
        ];

        for (let q = bounds.minQ - 1; q &lt;= bounds.maxQ + 1; q++) {
          for (let r = bounds.minR - 1; r &lt;= bounds.maxR + 1; r++) {
            const key = `${q},${r}`;
            const count = counts.get(key) || 0;
            const intensity = maxCount ? (count / maxCount) : 0;
            const color = getHeatmapColor(intensity);
            ctx.fillStyle = color;
            const centerX = R * sqrt3 * (q + 0.5 * r);
            const centerY = R * 1.5 * r;
            ctx.beginPath();
            for (let i = 0; i &lt; hexCorners.length; i++) {
              const corner = hexCorners[i];
              const gx = centerX + corner.x;
              const gy = centerY + corner.y;
              const globalX = offsetX + gx * cosT - gy * sinT;
              const globalY = offsetY + gx * sinT + gy * cosT;
              if (i === 0) ctx.moveTo(globalX, globalY);
              else ctx.lineTo(globalX, globalY);
            }
            ctx.closePath();
            ctx.fill();
          }
        }
      }

      function drawPoints() {
        ctx.fillStyle = "black";
        for (const p of points) {
          ctx.fillRect(p.x - 1, p.y - 1, 3, 3);
        }
      }

      function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        if (gridType === "square") {
          drawSquareGrid();
        } else if (gridType === "hex") {
          drawHexGrid();
        }
        drawPoints();
      }

      // Enable interactive dragging if flagged.
      if (model.get("interactive")) {
        canvas.addEventListener("pointerdown", (e) =&gt; {
          dragging = true;
          dragStartX = e.clientX;
          dragStartY = e.clientY;
          startOffsetX = offsetX;
          startOffsetY = offsetY;
          canvas.setPointerCapture(e.pointerId);
        });
        canvas.addEventListener("pointermove", (e) =&gt; {
          if (!dragging) return;
          const dx = e.clientX - dragStartX;
          const dy = e.clientY - dragStartY;
          offsetX = startOffsetX + dx;
          offsetY = startOffsetY + dy;
          draw();
        });
        canvas.addEventListener("pointerup", () =&gt; {
          dragging = false;
          model.set("grid_origin_x", offsetX);
          model.set("grid_origin_y", offsetY);
          model.save_changes();
        });
      }

      // Listen for parameter changes.
      model.on("change:canvas_size", () =&gt; {
        canvas.width = model.get("canvas_size");
        canvas.height = model.get("canvas_size");
        draw();
      });
      model.on("change:grid_type", () =&gt; {
        gridType = model.get("grid_type");
        draw();
      });
      model.on("change:cell_size", () =&gt; {
        cellSize = parseFloat(model.get("cell_size"));
        draw();
      });
      model.on("change:orientation", () =&gt; {
        orientation = parseFloat(model.get("orientation"));
        draw();
      });
      model.on("change:points", () =&gt; {
        points = model.get("points") || [];
        draw();
      });
      model.on("change:heatmap_colors", () =&gt; {
        heatmapColors = model.get("heatmap_colors");
        draw();
      });
      model.on("change:grid_origin_x", () =&gt; {
        offsetX = parseFloat(model.get("grid_origin_x")) || 0;
        draw();
      });
      model.on("change:grid_origin_y", () =&gt; {
        offsetY = parseFloat(model.get("grid_origin_y")) || 0;
        draw();
      });
      model.on("change:apply_filter", () =&gt; {
        applyFilter = model.get("apply_filter");
        draw();
      });

      // Initial draw.
      draw();
      model.set("ready", true);
      model.save_changes();
    }
    export default { render };
    """

    canvas_size = traitlets.Int(500).tag(sync=True)
    grid_type = traitlets.Unicode("square").tag(sync=True)   # "square" or "hex"
    cell_size = traitlets.Float(50.0).tag(sync=True)
    orientation = traitlets.Float(0.0).tag(sync=True)          # degrees
    points = traitlets.List(trait=traitlets.Dict(), default_value=[]).tag(sync=True)
    heatmap_colors = traitlets.List(trait=traitlets.Unicode(), default_value=["#009900AA", "#FFFF00AA", "#ff0000AA"]).tag(sync=True)
    grid_origin_x = traitlets.Float(0.0).tag(sync=True)
    grid_origin_y = traitlets.Float(0.0).tag(sync=True)
    interactive = traitlets.Bool(True).tag(sync=True)
    apply_filter = traitlets.Bool(False).tag(sync=True)
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-pre"><pre class="language-marimorena" tabindex="0"><code data-line="0" class="language-marimorena is-loaded">view1 = MAUPWidget(
    canvas_size=300,
    grid_type="square",
    cell_size=50,
    points=generate_points(100, 300, seed=1),
    grid_origin_x=-127.9337158203125,
    grid_origin_y=-2.0025634765625,
    interactive=False,
)
view2 = MAUPWidget(
    canvas_size = 300,
    grid_type = "square",
    cell_size = 50,
    points = generate_points(100, 300, seed=1),
    grid_origin_x=54.2108154296875,
    grid_origin_y=123.05267333984375,
    interactive=False,
)
mo.hstack([view1, mo.md("$\\to$"), view2], justify="center", align="center")
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-pre"><pre class="language-marimorena" tabindex="0"><code data-line="0" class="language-marimorena is-loaded">canvas_size = mo.ui.slider(100, 800, value=500, show_value=True)
orientation = mo.ui.slider(0, 360, value=0, show_value=True)
grid_type = mo.ui.dropdown(options=["square", "hex"], value="square")
cell_size = mo.ui.slider(10, 150, value=50, show_value=True)
num_points = mo.ui.slider(50, 500, value=200, show_value=True)
seed_slider = mo.ui.slider(0, 1000, value=0, show_value=True)
gauss_filter_switch = mo.ui.switch(False)

params = mo.md(f"""
| Parameter       | Value         |
|-----------------|---------------|
| Canvas Size     | {canvas_size} |
| Orientation     | {orientation} |
| Grid Type       | {grid_type}   |
| Cell Size       | {cell_size}   |
| NÂº Dots         | {num_points}  |
| Seed            | {seed_slider} |
| Gaussian Filter | {gauss_filter_switch} |
""")
regenerate = mo.ui.button(label="Regenerate")
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-pre"><pre class="language-marimorena" tabindex="0"><code data-line="0" class="language-marimorena is-loaded">widget = MAUPWidget(
	canvas_size=canvas_size.value,
	grid_type=grid_type.value,
	cell_size=cell_size.value,
	orientation=orientation.value,
	points=generate_points(num_points.value, canvas_size.value, seed=seed_slider.value if seed_slider.value else None),
	apply_filter=gauss_filter_switch.value,
)
mo.vstack(
	[
		mo.md("# Play With It\nDo not just take my word for it, try it yourself! Use the sliders to tweak the settings, then click and drag the grid on the canvas to see how different configurations completely transform the visualization.\n\nNote: Setting the seed to 0 means that no fixed seed is usedâ€”each generation will be completely random. Simply click the 'Regenerate' button to redraw a new set of points and see different outcomes."),
		mo.hstack([mo.vstack([params, mo.center(regenerate)]), widget], justify="start", gap=2),
	],
	gap=2,
)
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-pre"><pre class="language-python" tabindex="0"><code data-line="0" class="language-python is-loaded"><span class="token keyword">import</span> pandas <span class="token keyword">as</span> pd

pd<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-table" dir="ltr" style="overflow-x: auto;"><table>
<thead>
<tr>
<th dir="ltr">A</th>
<th dir="ltr">B</th>
</tr>
</thead>
<tbody>
<tr>
<td dir="ltr">a</td>
<td dir="ltr">b</td>
</tr>
</tbody>
</table></div><div class="mod-footer mod-ui"></div></div></div></div><div class="sidebar-right sidebar"><div class="sidebar-handle"></div><div class="sidebar-topbar"><div class="topbar-content"></div><div class="clickable-icon sidebar-collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><path d="M21 3H3C1.89543 3 1 3.89543 1 5V19C1 20.1046 1.89543 21 3 21H21C22.1046 21 23 20.1046 23 19V5C23 3.89543 22.1046 3 21 3Z"></path><path d="M10 4V20"></path><path d="M4 7H7"></path><path d="M4 10H7"></path><path d="M4 13H7"></path></svg></div></div><div class="sidebar-content"><div class="graph-view-wrapper"><div class="sidebar-section-header">Interactive Graph</div><div class="graph-view-placeholder">
		<div class="graph-view-container">
			<div class="graph-icon graph-expand" role="button" aria-label="Expand" data-tooltip-position="top"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><line x1="7" y1="17" x2="17" y2="7"></line><polyline points="7 7 17 7 17 17"></polyline></svg></div>
			<canvas id="graph-canvas" class="hide" width="512px" height="512px"></canvas>
		</div>
		</div></div><div class="tree-container mod-root nav-folder tree-item outline-tree" data-depth="0"><div class="tree-header"><span class="sidebar-section-header">Table Of Contents</span><button class="clickable-icon collapse-tree-button" aria-label="Collapse All"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></svg></button></div><div class="tree-scroll-area tree-item-children nav-folder-children"><div class="tree-item mod-tree-folder nav-folder mod-collapsible is-collapsed" style="display: none;"></div><div class="tree-item" data-depth="1"><a class="tree-link" href="the-cheese-cave/marimo-html-maup.html#Marimo HTML MAUP"><div class="tree-item-contents heading-link" heading-name="Marimo HTML MAUP"><span class="tree-item-title">Marimo HTML MAUP</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div></div><script defer="">let rs = document.querySelector(".sidebar-right"); rs.classList.add("is-collapsed"); if (window.innerWidth > 768) rs.classList.remove("is-collapsed"); rs.style.setProperty("--sidebar-width", localStorage.getItem("sidebar-right-width"));</script></div></div></body></html>